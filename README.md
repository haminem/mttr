# mttr
## 使い方 (CentOS7の場合)
### 1. リポジトリをクローンする
```
$ git clone
```
### 2. リポジトリに移動する
```
$ cd mttr
```
### 3. コンパイラとパッケージマネージャをインストールする
```
$ yum install gcc
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```
### 4. コンパイルする
```
$ cargo build
```
### 5. 実行する
```
$ target/debug/mttr [ファイル名] [N] [m] [t]
```
### 6. 結果を確認する
結果は`result/`に出力されます
```
ttr_server.txt -> N回以上タイムアウトしている期間(設問1・設問2)
overload.txt -> m回の平均応答時間がt以上の期間(設問3)
ttr_subnet.txt -> サブネット内のすべてのサーバーがn回以上タイムアウトしている期間(設問4)
```
### 7. テストケースを変更する
```
$ vim test/test.txt
```
もしくは
`test/`直下に`.txt`で配置してください
****
## テスト
`sample/`にテストケースと
```
$ target/debug/mttr test.txt 1 2 10
```
を実行した結果を配置しています
```
10000101000000,10.20.30.1/16,- <= タイムアウトを確認
10000101000001,10.20.30.2/16,- <= サブネットのタイムアウトを確認
10000101000002,10.20.30.1/16,1
10000101000003,10.20.30.2/16,-
10000101000004,10.20.30.2/16,1
10000101000005,10.20.30.1/16,- <= 二度目のタイムアウトを確認
10000101000006,10.20.30.2/16,- <= 二度目のサブネットのタイムアウトを確認
10000101000007,10.20.30.1/16,1
10000101000008,10.20.30.2/16,1
10000101000009,192.168.1.1/24,0
10000101000010,192.168.1.1/24,0
10000101000011,192.168.1.1/24,0
10000101000012,192.168.1.1/24,1000
10000101000013,192.168.1.1/24,1000 <= 一度目の過負荷状態を確認
10000101000014,192.168.1.1/24,1000
10000101000015,192.168.1.1/24,0
10000101000016,192.168.1.1/24,0
10000101000017,192.168.1.1/24,0
10000101000018,192.168.1.1/24,1000
10000101000019,192.168.1.1/24,1000 <= 二度目の過負荷状態を確認
10000101000020,192.168.1.1/24,1000
10000101000021,192.168.1.2/24,10
10000101000022,192.168.1.2/24,10 <= 複数の過負荷状態を確認
```

## 実装解説
### 全体的な意図
- データの流れが見えやすいように極力boolean以外での分岐を避ける
  - 各mapへのアクセスは`for`や`while`ではなく`entry`
    - そうすることで`if`ではなく`or_insert`や`and_modify`を使える
- 似たような値が複数存在しているためアクセスを読み易くする
  - `struct`を使って出力するデータ型をまとめる
    - `value.0.hoge`のような実装を避ける
- 監視ログのデータが膨大になっても耐えやすいようにする
  - `Vec`ではなく`HashMap`を使う
    - アクセスが`O(1)`であるため
  - できるだけ`&str`を使う
    - 値の複製を避けるため  <= これがrustを選んだ大きい理由です
### 1~6行目
`use`で必要なライブラリをインポートしています
### 8~32行目
有用な関数を切り分けたものを置いています
### 35~39行目
標準入力からファイル名と各パラメータを受け取ります
### 41~53行目
受け取ったパラメータをバリデーションし、不正なら終了します
### 55~70行目
各structを定義しています
### 72~77行目
各出力に必要なHashMapを定義しています
### 79~85行目
各出力に必要なフォルダ及びファイルを作成します
### 87~89行目
各出力用のlogを定義します
### 91~107行目
一度しか無いデータにも「サブネット内の全てのIP」を判断するために先に全てのIPを登録します
### 112~116行目
標準入力から1行ずつ読み込んで各値に分割します
### 118~192行目
先ずタイムアウトであるかどうかを判断します
その結果によって処理の異なる各HashMapへのアクセスを行います
### 194~220行目
過負荷状態であるかどうかを判断します
### 222~235行目
「一回以内の過負荷状態」という条件がロジックから漏れてしまうため個別に対応しました
### 237~247行目
データ採取時まで過負荷状態であるものを出力します
### 249~257行目
各出力用のlogを各ファイルに出力します
###課題
- サブネット内の全てのIPを登録するためのループ
  - サブネット周りの実装はサブネットが分散していればいるほど膨れ上がってしまうので、何か他の方法で対応したいです
- 一回以内の過負荷状態の判定がロジックから漏れてしまっている
  - このREADMEを書いているときに`or_insert_with`で実装できることに気づきました